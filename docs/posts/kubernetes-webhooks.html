<!DOCTYPE html>
<html lang="en"> 
<head profile="http://www.w3.org/2005/10/profile">
    <meta charset="UTF-8">
    <meta name="description" content="Alessandro Marrella. Welcome to my website!">
    <meta name="author" content="Alessandro Marrella">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@amarrella">
<meta name="twitter:creator" content="@amarrella">
<meta name="twitter:title" content="Kubernetes Webhooks in Haskell and Dhall">
    <meta name="twitter:description" content="How to write a kubernetes admission controller in Haskell">
        <title>Kubernetes Webhooks in Haskell and Dhall</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
</head>
<body>
    <header>
        <nav>
            <a id="beacon" href="/">
                <div id="home-text"> HOME </div>
            </a>
        </nav>
    
        <div class="right-sidebar">
            <a class="ext-link" href="https://github.com/amarrella">
            <img src="/images/github-logo.png" alt="Alessandro Marrella Github Profile"/>
        </a>

            <a class="ext-link" href="https://twitter.com/amarrella">
            <img src="/images/twitter-logo.png" alt="Alessandro Marrella Twitter Profile"/>
        </a>

            <a class="ext-link" href="https://linkedin.com/in/alessandromarrella">
            <img src="/images/linkedin-logo.png" alt="Alessandro Marrella Linkedin Profile"/>
        </a>
    </div>
    </header>

<div id="page">
    <div class="wrapper">
        <div class="masthead">
            <span class="title">
                Kubernetes Webhooks in Haskell and Dhall
            </span>
            <br>

            <br>
            <span class="byline">by Alessandro Marrella</span>
            <br>
            <span class="date">2020-02-09</span>
            <br>
            <div class="metadata">
            </div>
        </div>
    </div>
    <article class="post">
        <p>I spent the past few weeks fighting with Kubernetes <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Admission Controllers</a> (also known as Mutating/Validating Webhooks).</p>
<p>Admission controllers are a quite powerful tool, that allow intercepting requests to the Kubernetes API Server before an object is persisted, and perform custom validations or mutations on it.</p>
<p>There are two main components to an admission controller: 1. A <em>webhook</em> exposed over HTTPS which accepts an <code>AdmissionReviewRequest</code> and returns an <code>AdmissionReviewResponse</code> 2. A <em>configuration</em> entry of type <code>MutatingWebhookConfiguration</code> or <code>ValidatingWebhookConfiguration</code></p>
<p>In this post, I will present the <a href="https://hackage.haskell.org/package/kubernetes-webhook-haskell">kubernetes-webhook-haskell</a> library, which is used to create the webhook, and a <code>dhall</code> template that helps with the configuration and tls certificates. Many tutorials I found online show how to do this with a bash script, here we take a more declarative approach using <a href="https://cert-manager.io">cert-manager</a>.</p>
<h2 id="how-to-write-a-kubernetes-webhook-in-haskell">How to write a Kubernetes Webhook in Haskell</h2>
<p>This is a step by step explanation on how to write a webhook in Haskell. If you are familiar with Haskell, and servant, you can skip this section and <a href="https://github.com/EarnestResearch/kubernetes-webhook-haskell#kubernetes-webhook-haskell">look at the example</a> instead.</p>
<p>First of all, <em>set up a project</em> using your favorite build tool, adding <code>kubernetes-webhook-haskell</code> as a dependency.</p>
<p>Second, you need to <em>create an endpoint</em> where you will be receiving the requests. In <code>servant</code>, this looks like: <code>haskell type API =   -- /mutate   "mutate" :&gt; ReqBody '[JSON] AdmissionReviewRequest :&gt; Post '[JSON] AdmissionReviewResponse</code></p>
<p>Third, you need to <em>set up the server so that it runs on https</em> (kubernetes only allows https for webhooks), with <code>warp-tls</code> you can do something like:</p>
<p><code>haskell main :: IO () main = do   let tlsOpts = tlsSettings "/certs/tls.crt" "/certs/tls.key"       warpOpts = setPort 8080 defaultSettings   runTLS tlsOpts warpOpts app</code> If you will be using the template provided in the section below, we will load the certificates there.</p>
<p>Fourth, you can <em>write the webhook logic</em>. Depending on whether you are writing a validating or a mutating webhook, the library exposes two different functions: <code>mutatingWebhook</code> and <code>validatingWebhook</code>. The logic is similar for both, you parse a request, write a handler for it returning either an error (of type <code>Status</code>) or a <code>Allowed</code>/<code>Patch</code> (see <a href="http://jsonpatch.com/" class="uri">http://jsonpatch.com/</a> for information on how to write the patch).</p>
<p>For example, if you want to write a mutating webhook that adds a toleration to your pods, you should define the Toleration type: ```haskell data Toleration = Toleration { effect :: Maybe TolerationEffect, key :: Maybe Text, operator :: Maybe TolerationOperator, tolerationSeconds :: Maybe Integer, value :: Maybe Text } deriving (Generic, A.ToJSON)</p>
<p>data TolerationEffect = NoSchedule | PreferNoSchedule | NoExecute deriving (Generic, A.ToJSON)</p>
<p>data TolerationOperator = Exists | Equal deriving (Generic, A.ToJSON) ```</p>
<p>and then your patch can look like: <code>haskell patch :: W.Patch patch =   W.Patch     [          W.PatchOperation         { op = W.Add,           path = "/spec/tolerations/-",           from = Nothing,           value = Just $ A.toJSON toleration         }     ]   where      toleration =        Toleration         { effect = Just NoSchedule,           key = Just "foo",           operator = Just Equal,           tolerationSeconds = Nothing,           value = Nothing         }</code></p>
<p>Then your patch in the <code>mutatingWebhook</code>: <code>haskell mutate :: AdmissionReviewRequest -&gt; AdmissionReviewResponse mutate = mutatingWebhook req (\_ -&gt; Right patch)</code></p>
<p>And that's it! Compile and create a docker image, and jump to the next section.</p>
<h2 id="how-to-deploy-the-kubernetes-webhook-using-dhall">How to deploy the Kubernetes Webhook using Dhall</h2>
<p>Regardless of the fact that you created the webhook with the library above or not, this part explains how to deploy a webhook to Kubernetes by using an opinionated Dhall template.</p>
<p>Dhall is a configuration language aimed at writing maintainable configuration files. It's a great language to write infrastructure configuration in, with features such as: - (safe) imports - functions - types - See <a href="https://dhall-lang.org">dhall-lang.org</a> for more information about the language.</p>
<p>As a <em>pre-requisite</em> for this part, you need to: - Install <a href="https://cert-manager.io">cert-manager</a> in your cluster. This has been tested with cert-manager <code>v0.13.0</code> with the ca-injector enabled. - Install <a href="https://dhall-lang.org">dhall-to-yaml</a> on your laptop or in your continuous deployment / gitops. This has been tested with dhall-to-yaml <code>v1.6.1</code>.</p>
<p>Then, <em>add a custom label</em> to the namespaces you want to apply the webhook to: <code>sh kubectl label namespace my-namespace my-webhook=enabled</code></p>
<p>Deploying a webhook now is as easy as replacing the values in this example with yours: ```haskell -- webhook.dhall let k8s = <a href="https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/6a47bd50c4d3984a13570ea62382a3ad4a9919a4/1.14/package.dhall" class="uri">https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/6a47bd50c4d3984a13570ea62382a3ad4a9919a4/1.14/package.dhall</a></p>
<p>let Webhook = <a href="https://raw.githubusercontent.com/EarnestResearch/dhall-packages/v0.11.1/kubernetes/webhook/package.dhall" class="uri">https://raw.githubusercontent.com/EarnestResearch/dhall-packages/v0.11.1/kubernetes/webhook/package.dhall</a></p>
<p>let config = Webhook::{ , imageName = "docker/whalesay" -- replace with your webhook docker image , name = "my-mutating-webhook" -- replace with a meaningful name , namespace = "default" -- replace with the namespace where you want to deploy it , path = "/mutate" -- replace with the path where the webhook is exposed , port = 8080 --replace with the port where the webhook is exposed , rules = -- replace with the rules you care about [ k8s.RuleWithOperations::{ , operations = [ "CREATE", "UPDATE" ] , apiGroups = [ "" ] , apiVersions = [ "v1" ] , resources = [ "pods" ] } ] , namespaceSelector = Some k8s.LabelSelector::{ , matchLabels = toMap { my-webhook = "enabled" } -- replace with the label you used for the namespace } }</p>
<p>in Webhook.renderMutatingWebhook config -- or Webhook.renderValidatingWebhook ```</p>
<p>Once the file is ready, run <code>echo ./webhook.dhall | dhall-to-yaml --omit-empty | kubectl apply -n default -f -</code></p>
<p>The webhook will be installed and ready to use, with all the certificates loaded.</p>
    </article>

</div>

<footer>
    <p>© Alessandro Marrella 2020 - All opinions expressed are my own.</p>
    <p>Built with Haskell using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️</p>
</footer>

<script src="/js/main.js"></script>
</body>
</html>
